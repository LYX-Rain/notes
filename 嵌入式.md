# 嵌入式

## 嵌入式系统概述

- 嵌入式系统组成：
  - 硬件电路：接口电路、处理器系统电路、系统专用电路
  - 应用软件
  - 实时操作系统
- 嵌入式系统的特点
  - 嵌入性：由于嵌入到对象体系中，必须满足对象系统的环境要求
  - 专用性：嵌入式系统的软、硬件均是面向特定应用对象和任务设计的，具有很强的专用性和多样性
  - 计算机平台：嵌入式系统必须是能满足对象系统控制要求的计算机系统
  - 嵌入式系统的软件固化在非易失性存储器中
  - 嵌入式系统大都有实时性要求，需要在规定的时限内对事件做出正确的反应，如汽车刹车系统

## 计算机体系结构

- 计算机的组成
  - 硬件系统：计算机中那些看得见摸得着的物理实体，是计算机的物质基础，包括计算机内部的电子线路和物理装置
    - 存储器：计算机中用于存放程序和数据的部件
    - 运算器：用于信息处理和运算的部件，它对数据进行算术、逻辑运算。运算器通常由算术逻辑部件（ALU）和一系列寄存器组成。ALU是具体完成算术运算与逻辑运算的部件，寄存器用于存放运算的操作数
    - 控制器是整个计算机的控制机构，其功能就是按照事先确定的步骤，控制运算器、存储器和输入设备、输出设备，统一协调地完成所需要的操作
    - 输入设备：把人们编好的程序和原始数据输送到计算机中去，并且把其转换成计算机内部所能识别和接收的信息
    - 输出设备：将计算机的处理结果以人或其他设备所能理解或接收的形式输出，输出信息的形式同样有字符、文字、图形、图像、声音等
  - 软件系统：
    - 操作系统
    - 语言处理程序
    - 标准库程序
    - 服务性程序

- 计算机系统性能量化：
  - Amdahl定律：加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比
  - $$系统性能加速比= \frac{系统性能_{改进后}}{系统性能_{改进前}} = \frac{总执行时间_{改进前}}{总执行时间_{改进后}} $$
  - 加速比依赖于两个因素：
    - 可改进比例：在改进前的系统中，可改进部分的执行时间在总的执行时间中所占的比例称为可改进比例，它总是小于等于1。
      - 例如：一个需运行60秒的程序中有20秒的运算可以加速，那么这个比例就是20/60
    - 部件加速比：可改进部分改进以后性能提高的倍数称为部件加速比。它是改进前所需的执行时间与改进后执行时间的比，部件加速比总是大于1。
      - 例如：若系统改进后，可改进部分的执行时间是2秒，而改进前其执行时间为5秒，则部件加速比为5/2
  - $$加速比= \frac{1}{(1-可改进比)+ \frac{可改进比}{部件加速比} }$$
  - Amdahl定律揭示了计算机系统性能改进的两种局限。
    - 第一，部分性能改进的递减局限。即如果仅仅对计算机系统的一部分做性能改进，则改进得越多，所得到的总体性能的提升就越有限。
    - 第二，对计算机系统进行部分性能改进，系统加速比存在极限，极限为1/(1-可改进比例)。
  - CPU性能公式
    - $$CPU时间=程序CPU时钟周期数×时钟周期=\frac{程序的CPU时钟周期数}{时钟频率}$$
    - $$CPU时间=IC×CPI×CCT$$
    - 影响CPU时间的3个性能参数中，CCT主要取决于芯片加工工艺及CPU硬件结构，CPI主要取决于CPU硬件结构及指令集架构（ISA：Instruction Set Architecture），IC则主要取决于ISA和编译技术

## 储存器系统

### 储存器类型

- 按照存储介质分类
  - 半导体储存器：速度快，用作内存
    - 记忆原理：通过触发器（如SRAM）、电容（如DRAM）或浮动栅门（如闪存）对电位的保持作用来存储二进制数据
    - 双极型晶体管
    - 场效应管
  - 磁表面存储器：利用涂覆在载体表面的磁性材料具有两种不同的磁化状态来表示“0”和“1”
    - 存储容量大、单位价格低、记录介质可以重复使用、记录信息可以长期保存而不丢失
    - 可以脱机存档、支持非破坏性读出（读出时不会改变存储元的状态）
  - 光存储器：信息以刻痕的形式保存在盘面上，用激光束照射盘面，靠盘面的不同反射率来读出信息
    - 存储密度高、存储寿命长、价格低
- 按照存取方式分类
  - 随机访问存储器（RAM）
    - 存储单元的内容可按需随意取出或存入，且存取的速度与存储单元的位置无关
    - RAM在断电时将丢失其存储内容
    - RAM可以进一步分为静态随机存储器（SRAM）和动态随机存储器（DRAM）
  - 只读存储器ROM
    - ROM是存储固定信息的存储器，一般是事先写好的，在工作过程中只能读出，不能改写，常用于存储各种固定程序和数据
    - ROM中所存数据在断电后也不会发生改变
  - 顺序存取存储器
    - 在存取信息时，只能按存储单元的位置，顺序地一个接一个地进行数据的存取
  - 按照存储器信息的可保存性分类
    - 根据断电后是否丢失数据，可将存储器分为易失性存储器和非易失性存储器。易失性存储器在断电后，信息就会丢失，例如SRAM。非易失性存储器或称为永久性存储器在断电后，信息不丢失，例如硬盘
    - 根据读出后是否保持数据，可将存储器分为破坏性存储器和非破坏性存储器。破坏性存储器在数据读出时，原存信息会被破坏，需要重新写入，例如DRAM。非破坏性存储器在数据读出时，原存信息不会被破坏，因而也不需要重新写入，大部分存储器都属于这个类型。
  - 高速缓冲存储器（Cache，简称缓存）是存在于主存与CPU之间的一级存储器，容量相对较小但速度比主存高得多，接近于CPU的速度。缓存一般与CPU集成在同一个芯片中，因此也称之为片上存储，一般用SRAM构建
  - 计算机系统中的主要存储器又称内存，用来存储计算机运行期间较常用的大量的程序和数据。主存一般存在于CPU主板上，常用DRAM构建
- Flash Memory(快闪存储器)
  - Flash Memory是一种可以直接在主机板上修改内容而不需要将IC拔下的内存，当电源关掉后储存在里面的资料并不会流失掉，在写入资料时必须先将原本的资料清除掉，然后才能再写入新的资料，缺点为写入资料的速度太慢
  - 目前嵌入式系统所采用的Flash主要有NOR Flash及NAND Flash
  - NOR的特点是芯片内执行，这样应用程序可以直接在Flash内运行，不必再把代码读到系统RAM中。NOR的传输效率很高，在1～4 MB的小容量时具有很高的成本效益，但是很低的写入和擦除速度大大影响了它的性能
  - NAND结构能提供极高的单元密度，可以达到高存储密度，并且写入和擦除的速度也很快。应用NAND的困难在于Flash的管理和需要特殊的系统接口 
  - 通常用NOR Flash存储启动代码，NAND Flash存储操作系统和应用程序代码。

### 分层存储系统性能
 
- 高速缓冲存储器(Cache)是位于主存与CPU之间的高速小容量存储器，用来存放程序中当前最活跃的程序和数据
- Cache 的命中
  - 当CPU欲访问某主存字时的两种情况：
  1. 所需内容已在Cache中，称为CPU访问Cache 命中，CPU可直接访问Cache
  2. 所需内容不在Cache中，称为CPU访问Cache不命中（失败）。CPU需访问主存获得所需内容，并将包含所需内容的主存块调入Cache中，以备下次访问
- Cache 命中率：CPU要访问的内容在Cache中的比率
  - 设在一个程序执行期间，访问 Cache 的总命中次数为 $N_c$，访问主存的次数为$N_m$，CPU 访问 Cache 的命中率为H，则有：
  - $$H = \frac{N_c}{N_c+N_m}$$
- Cache的工作过程
  1. 当CPU需要进行访存时，首先给出主存实地址
  2. 地址映像变换机构接收到主存实地址后，根据块号判定所访问的信息字是否在Cache中
    - 若在(Cache命中)，通过地址变换机构将主存块号变换为Cache块地址，再根据块内偏移量，对Cache进行存取
    - 若不在(Cache不命中)，则通知访问Cache块失效。然后通过CPU与主存之间的直接数据通路访问主存，将被访问字直接送给CPU，并将包含该字的新块装入Cache
- Cache的地址映像方式
  - 因为CPU以主存地址访问Cache，所以访存时必须把主存地址变换为Cache的实际地址
  1. 直接映像方式
    - 任何一个主存块只能复制到Cache的某一固定块中
    - 直接映像实际是将主存以Cache的大小划分为若干区，每一区的第0块只能复制到Cache的第0块，每一区的第1块只能复制到Cache的第1块，……
    - ![直接映像方式](image\直接映像方式.jpg)
    - 采用直接映像方式时，主存地址分成三段：
    - 标识（区号） | 区内块号 | 块内偏移量
      - 标识（区号）用于判断Cache命中与否
      - 区内块号直接用于在Cache中进行块寻址
      - 块内偏移量用于块内字或字节的寻址
      - 地址映像机构在判断块命中与否时，只需判断Cache中某一块对应于主存中哪一区即可
    - 地址变换方式
      - 利用标识Cache中的内容实现地址变换
      - 标识Cache用于存放主存块在Cache中的调入情况。标识Cache共有$2^m$个单元，每个单元对应一个Cache块，每个单元中标识信息长n－m位
      - ![直接映像地址](image/直接映像地址.jpg)
      - 直接映像下的标识Cache
        - ![直接映像标识cache](image/直接映像标识cache.jpg)
      - 直接映像地址变换
      - ![直接映像地址变换](image/直接映像地址变换.png)
    - 直接映像方式的特点：
      1. 硬件线路简单
      2. 地址变换速度快
      3. 因为主存块在Cache中的位置固定，一个主存块只能对应一个Cache块，所以没有替换策略问题
      4. 块的冲突率高，若程序往返访问两个相互冲突的块，将会使命中率急剧下降
      5. Cache利用率低
  2. 全相联映像及变换
    - 任何主存块可映像到任意一个Cache块
    - ![全相联映像方式](image/全相联映像方式.jpg)
    - 地址变换方式
      - 在全相联映像中，主存块号作为标识，块内偏移量作为索引。主存无分区的概念
      - 主存地址：标识（cache标识） | 块内偏移量
      - ![全相联映像标识cache](image/全相联映像标识cache.jpg)
      - 在访存操作时，根据主存地址中的块号在标识Cache中查找是否有相同的主存块号
      - 如果有相同的主存块号，则表示Cache命中，根据对应的Cache块号，对Cache进行访问
      - 如果标识Cache中没有相同的主存块号，则表示Cache不命中，需要对主存进行访问并将主存中的块调入Cache中，同时还要将主存块号写入调入的Cache块对应的标识Cache单元中，以改变地址映像关系
      - 在调入新的主存数据块时，需根据替换策略确定将Cache中的哪一个数据块替换出去
      - ![全相联映像地址变换](image/全相联映像地址变换.png)
    - 全相联映像方式的特点
      1. 块冲突概率小，Cache命中率高
        - 全相联方法只有在Cache中的块全部装满后才会出现块冲突，所以块冲突概率小 
      2. Cache利用率高
      3. 由于需要相联存储器实现相联访问和实现替换策略的硬件，故硬件复杂，成本高
      4. 相联访问影响访问速度
  3. 组相联映像方式
    - 组相联映像是前两种方式的一种折衷方式
    - 先将Cache块分为若干组，每组中有相同数量的Cache块，再将主存块按与Cache组相同的组数进行分组
    - 规定：主存中的任何一组只能映像到Cache中的某一固定组（类似直接映像），但同一组中的主存块可调入Cache中指定组内的任意块中（类似全相联映像）
    - ![组相联映像方式](image/组相联映像方式.jpg)
    - 将主存第i 块映像到Cache的第k组，即:
    - k＝i mod G  （G为Cache的组数）
    - 即主存块号除以Cache组数同余的块被映射在一组中
    - 设主存有2n块，Cache有2m块，组数$G＝2^g$，则当用二进制数表示地址时，G 实际上就是主存块地址 i 的低 g 位
    - ![组相联映像地址](image/组相联映像地址.jpg)
    - 在组相联映像方式下，同一组中的主存块可调入Cache中一个指定组内的任意块中
    - ![组相联映像地址变换](image/组相联映像地址变换.png)
    - 组相联映像下的标识Cache
    - ![组相联映像标识cache](image/组相联映像标识cache.jpg)
    - 在访存操作时，根据访存地址中的组号，在块表中查找该组对应的若干项中是否有相应的主存标识
    - 如果有且有效位为“1”，表示Cache命中，将在对应的Cache块中根据块内偏移地址对Cache中的相应单元进行访问
    - 如果没有或有效位为“0”，表示不命中，对主存进行访问并将主存中的块按所属的组调入Cache组中合适的块中，同时将主存的组内块号写入标识Cache，以改变地址映像关系
    - 在新的数据块调入时，还需确定将组内的哪一个数据块替换出去

## CPU硬件结构

- 最小硬件系统
- ![最小硬件系统](image/最小硬件系统.png)

## ARM体系结构

- 两种指令集
  - 16位的Thumb指令集和32位ARM指令集
  - Thumb指令集是ARM指令集的子集。也就意味着每条Thumb指令都有对应的ARM指令，但反之不一定
- 两种工作状态
  - 执行Thumb指令集时工作在Thumb状态下。16bit取指，16bit译码
  - 执行ARM指令集时工作在ARM状态下。32bit取指，32bit译码

- ARM处理器有37个寄存器
  - 31个通用寄存器：程序计数器、堆栈及其他通用寄存器
  - 6个状态寄存器
  - 这些寄存器不能同时看到，不同的处理器状态和工作模式确定哪些寄存器是对编程者是可见的
  - ![ARM State Registers](image/ARM&#32;State&#32;Registers.png)
  - 通用寄存器是R0-R15的寄存器，分为三类 
    - 没有对应影子寄存器的寄存器R0-R7 
    - 有对应影子寄存器的寄存器R8-R14
    - 程序计数器R15 (或者PC) 
  - 影子寄存器是指该寄存器在不同的模式下对应的物理寄存器
  - R0-R7
  - 所有模式下，R0-R7所对应的物理寄存器都是相同的
  - 这八个寄存器是真正意义上的通用寄存器
  - 在中断或者异常处理程序中一般都需要对这几个寄存器进行保存
- R8-R14
  - 访问的物理寄存器取决于当前的处理器模式
  - R8-R12各有两组物理寄存器：一组为FIQ模式，另一组是除FIQ以外的其他模式
  - R13-R14各有6个分组的物理寄存器，一个用于用户模式和系统模式，其他5个分别用于5种异常模式
  - R13（也被称为SP指针）被用作栈指针，通常在系统初始化时需要对所有模式下的SP指针赋值，当CPU在不同的模式时栈指针会被自动切换成相应模式下的值
  - R14有两个用途，一是在调用子程序时用于保存调用返回地址，二是在发生异常时用于保存异常返回地址
- CPSR（当前程序状态寄存器）在所有的模式下都是可以读写的，记录当前的处理器状态（程序状态），它主要包含：
  - 条件标志
  - 中断使能标志
  - 当前处理器的模式
  - 其它的一些状态和控制标志

### ARM指令集

- \<op\>{\<cond\>}{S} \<Rd\>,\<Rn\>,\<operand2\>
  - op：操作码，指令功能
  - cond：条件码，执行条件
  - S：状态位，执行结果是否影响状态寄存器
  - Rd：目的寄存器
  - Rn：第1操作数，来源于寄存器Rn
  - operand2：第2操作数
- 条件执行：几乎所有的指令均可包含一个可选的条件码，满足条件码的指令才能执行。如：ADDEQ

### Load/Store指令

- RISC处理器的一大特色就是Load/Store架构，即只有Load/Store指令才能访问存储器
- Load用于把内存中的数据装载到寄存器，Store指令用于把寄存器中的数据存入内存，实现寄存器文件和存储器的数据交换
- 在存储器和寄存器之间传送单一数据指令LDR和STR
- 指令格式： op{cond} type Rd , 地址
  - type表示传送数据的类型，必须是下列值之一：
  - D：表示双字、空：表示字
  - SH：带符号半字、H：无符号半字
  - B：无符号字节、SB：带符号字节

#### 字和无符号字节加载/存储指令

- LDR/STR指令寻址非常灵活，它由两部分组成，其中一部分为一个基址寄存器，可以为任一个通用寄存器；另一部分为一个地址偏移量。地址偏移量有以下3种格式：
- 立即数。立即数可以是一个无符号的数值。这个数据可以加到基址寄存器，也可以从基址寄存器中减去这个数值
  - LDR  R1,[R0,#0x12] ;    R1<-[R0+0x12]
- 寄存器。寄存器中的数值可以加到基址寄存器，也可以从基址寄存器中减去这个数值
  - LDR  R1,[R0,R2]  ;      R1<-[R0+R2]
  - LDR  R1,[R0,-R2] ;      R1<-[R0-R2]
- 寄存器及移位常数。寄存器移位后的值可以加到基址寄存器，也可以从基址寄存器中减去这个数值
  - LDR  R1,[R0,R2,LSL #2] ;R1<-[R0+R2*4]
- 单一加载/存储指令的变址模式有四种：零偏移、前变址、后变址、回写前变址。
- 注意：必须保证字数据操作的地址是32位对齐的
- ![变址模式](image/变址模式.png)

#### 半字和有符号字节加载/存储指令

- LDR{cond}SB Rd,<地址>;将指定地址上的有符号字节读入Rd
- LDR{cond}SH Rd,<地址>;将指定地址上的有符号半字读入Rd
- LDR{cond}H   Rd,<地址>;将指定地址上的半字数据读入Rd
- STR{cond}H   Rd,<地址>;将Rd中的半字数据存入指定地址
- 注意：
  1. 有符号位半字/字节加载是指用符号位加载扩展到32位，无符号半字加载是指用零扩展到32位；
  2. 半字读写的指定地址必须为偶数，否则将产生不可靠的结果
- 应用示例：
  1. 加载/存储字和无符号字节指令
    - LDR	R2,[R5]	;将R5指向地址的字数据存入R2
    - STR	R1,[R0,#0x04]	;将R1的数据存储到R0+0x04地址
    - LDRB	R3,[R2],#-1 	;将R2指向地址的字节数据存入R3，R2＝R2－1
    - STRB	R0,[R3,-R8 ASR ＃2] ;R0->[R3-R8/4],存储R0的最低有效字节
  2. 加载/存储半字和有符号字节指令
    - LDRSB  R1,[R0,R3]	;将R0+R3地址上的字节数据存入R1，高24位用符号扩展
    - LDRH   R6,[R2],#2	;将R2指向地址的半字数据存入R6，高16位用0扩展，读出后，R2=R2+2
    - STRH   R1,[R0,#2]!;将R1的半字数据保存到R0+2地址，只修改低2字节数据，然后R0=R0+2

### 数据处理指令

- ADD、ADC 、SUB 、SBC、RSB、RSC
- 格式：op {cond} {S} Rd, Rn, Operand2
- 说明：
  - ADD(ADC)：Rn+Operand2→Rd (带进位加)
  - SUB(SBC)： Rn-Operand2→Rd (带进位减)
  - RSB(RSC) ：Operand2-Rn→Rd (带进位减)
- 与AND、或ORR、异或EOR和位清零BIC
- 格式：op {cond} {S} Rd, Rn, Operand2
- 说明：
  - BIC：将Rn中的位与 Operand2之中相应位的反码进行与操作，结果送Rd 。
  - 其它命令实现Rn OP Operand2 →Rd
  - ![逻辑运算指令](image/逻辑运算指令.png)
- 传送MOV和传送取反值MVN 指令
- 格式：OP {cond} {S}  Rd, Operand2
- 说明：
  - MVN将Operand2按位取反送Rd
  - Operand2只能是寄存器或立即数
- 分支指令
- ![分支指令](image/分支指令.png)
- 直接转移指令B
- 该指令跳转范围限制在当前指令的±32M字节地址内(ARM指令为字对齐，最低2位地址固定为0)。指令格式如下：
- B WAITA			; 跳转到WAITA标号处 
- B 0x1234		; 跳转到绝对地址0x1234处
- 带链接转移BL指令
- Label为程序相对偏移表达式；BL指令先将下一条指令的地址拷贝到R14，然后转移到label

## 寻址方式

- 根据指令中给出的地址信息取得操作数物理地址的方式。
- 对于ARM指令来说，一般特指找到operand2的方式
- Operand2形式：
  - #immed_8r、 Rm、 Rm, shift（寄存器+移位）
- 寄存器寻址
  - 操作数的值在寄存器中，指令中的地址码字段指出的是寄存器编号，指令执行时直接取出寄存器值来操作
  - MOV  R1,R2	    ;将R2的值存入R1 
  - SUB  R0,R1,R2    ;将R1的值减去R2的值，结果保存到R0 
- 立即寻址
  - 立即寻址指令中的操作码字段后面的地址码部分即是操作数本身，也就是说，数据就包含在指令当中，取出指令也就取出了可以立即使用的操作数(这样的数称为立即数)
  - SUBS	R0,R0,#1     ;R0减1，结果放入R0，并且影响标志位
  - MOV	  R0,#0xFF000  ;将立即数0xFF000装入R0寄存器
  - 立即数
    - 有效的立即数很少。它必须由一个8位的立即数循环右移偶数位得到

### S3C2410的启动

- S3C2410内部具有NAND Flash控制器，因此可以选择从NOR Flash或从NAND Flash进行启动，可通过OM[1:0]来进行设置。
- 当系统从NOR Flash启动时，要把Flash芯片的首地址映射到0x0000_0000位置；
- 当系统从NAND Flash启动时，S3C2410则会自动将NAND Flash的前面4 KB数据搬移到S3C2410内部的SRAM中，并将内部SRAM的首地址设为0x0000_0000，CPU从地址0x0000_0000处开始运行